import http from 'https';
import { Buffer as Buffer$1 } from 'node:buffer';
import * as crypto from 'node:crypto';
import { KeyObject, createPublicKey, constants, createSecretKey } from 'node:crypto';
import * as util from 'node:util';
import { promisify } from 'node:util';

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

const encoder = new TextEncoder();
const decoder = new TextDecoder();
function concat(...buffers) {
    const size = buffers.reduce((acc, { length }) => acc + length, 0);
    const buf = new Uint8Array(size);
    let i = 0;
    buffers.forEach((buffer) => {
        buf.set(buffer, i);
        i += buffer.length;
    });
    return buf;
}

function normalize(input) {
    let encoded = input;
    if (encoded instanceof Uint8Array) {
        encoded = decoder.decode(encoded);
    }
    return encoded;
}
const decode = (input) => new Uint8Array(Buffer$1.from(normalize(input), 'base64'));

class JOSEError extends Error {
    static get code() {
        return 'ERR_JOSE_GENERIC';
    }
    code = 'ERR_JOSE_GENERIC';
    constructor(message) {
        super(message);
        this.name = this.constructor.name;
        Error.captureStackTrace?.(this, this.constructor);
    }
}
class JWTClaimValidationFailed extends JOSEError {
    static get code() {
        return 'ERR_JWT_CLAIM_VALIDATION_FAILED';
    }
    code = 'ERR_JWT_CLAIM_VALIDATION_FAILED';
    claim;
    reason;
    constructor(message, claim = 'unspecified', reason = 'unspecified') {
        super(message);
        this.claim = claim;
        this.reason = reason;
    }
}
class JWTExpired extends JOSEError {
    static get code() {
        return 'ERR_JWT_EXPIRED';
    }
    code = 'ERR_JWT_EXPIRED';
    claim;
    reason;
    constructor(message, claim = 'unspecified', reason = 'unspecified') {
        super(message);
        this.claim = claim;
        this.reason = reason;
    }
}
class JOSEAlgNotAllowed extends JOSEError {
    static get code() {
        return 'ERR_JOSE_ALG_NOT_ALLOWED';
    }
    code = 'ERR_JOSE_ALG_NOT_ALLOWED';
}
class JOSENotSupported extends JOSEError {
    static get code() {
        return 'ERR_JOSE_NOT_SUPPORTED';
    }
    code = 'ERR_JOSE_NOT_SUPPORTED';
}
class JWSInvalid extends JOSEError {
    static get code() {
        return 'ERR_JWS_INVALID';
    }
    code = 'ERR_JWS_INVALID';
}
class JWTInvalid extends JOSEError {
    static get code() {
        return 'ERR_JWT_INVALID';
    }
    code = 'ERR_JWT_INVALID';
}
class JWSSignatureVerificationFailed extends JOSEError {
    static get code() {
        return 'ERR_JWS_SIGNATURE_VERIFICATION_FAILED';
    }
    code = 'ERR_JWS_SIGNATURE_VERIFICATION_FAILED';
    message = 'signature verification failed';
}

var isKeyObject = (obj) => util.types.isKeyObject(obj);

const webcrypto = crypto.webcrypto;
const isCryptoKey = (key) => util.types.isCryptoKey(key);

function unusable(name, prop = 'algorithm.name') {
    return new TypeError(`CryptoKey does not support this operation, its ${prop} must be ${name}`);
}
function isAlgorithm(algorithm, name) {
    return algorithm.name === name;
}
function getHashLength(hash) {
    return parseInt(hash.name.slice(4), 10);
}
function getNamedCurve$1(alg) {
    switch (alg) {
        case 'ES256':
            return 'P-256';
        case 'ES384':
            return 'P-384';
        case 'ES512':
            return 'P-521';
        default:
            throw new Error('unreachable');
    }
}
function checkUsage(key, usages) {
    if (usages.length && !usages.some((expected) => key.usages.includes(expected))) {
        let msg = 'CryptoKey does not support this operation, its usages must include ';
        if (usages.length > 2) {
            const last = usages.pop();
            msg += `one of ${usages.join(', ')}, or ${last}.`;
        }
        else if (usages.length === 2) {
            msg += `one of ${usages[0]} or ${usages[1]}.`;
        }
        else {
            msg += `${usages[0]}.`;
        }
        throw new TypeError(msg);
    }
}
function checkSigCryptoKey(key, alg, ...usages) {
    switch (alg) {
        case 'HS256':
        case 'HS384':
        case 'HS512': {
            if (!isAlgorithm(key.algorithm, 'HMAC'))
                throw unusable('HMAC');
            const expected = parseInt(alg.slice(2), 10);
            const actual = getHashLength(key.algorithm.hash);
            if (actual !== expected)
                throw unusable(`SHA-${expected}`, 'algorithm.hash');
            break;
        }
        case 'RS256':
        case 'RS384':
        case 'RS512': {
            if (!isAlgorithm(key.algorithm, 'RSASSA-PKCS1-v1_5'))
                throw unusable('RSASSA-PKCS1-v1_5');
            const expected = parseInt(alg.slice(2), 10);
            const actual = getHashLength(key.algorithm.hash);
            if (actual !== expected)
                throw unusable(`SHA-${expected}`, 'algorithm.hash');
            break;
        }
        case 'PS256':
        case 'PS384':
        case 'PS512': {
            if (!isAlgorithm(key.algorithm, 'RSA-PSS'))
                throw unusable('RSA-PSS');
            const expected = parseInt(alg.slice(2), 10);
            const actual = getHashLength(key.algorithm.hash);
            if (actual !== expected)
                throw unusable(`SHA-${expected}`, 'algorithm.hash');
            break;
        }
        case 'EdDSA': {
            if (key.algorithm.name !== 'Ed25519' && key.algorithm.name !== 'Ed448') {
                throw unusable('Ed25519 or Ed448');
            }
            break;
        }
        case 'ES256':
        case 'ES384':
        case 'ES512': {
            if (!isAlgorithm(key.algorithm, 'ECDSA'))
                throw unusable('ECDSA');
            const expected = getNamedCurve$1(alg);
            const actual = key.algorithm.namedCurve;
            if (actual !== expected)
                throw unusable(expected, 'algorithm.namedCurve');
            break;
        }
        default:
            throw new TypeError('CryptoKey does not support this operation');
    }
    checkUsage(key, usages);
}

function message(msg, actual, ...types) {
    if (types.length > 2) {
        const last = types.pop();
        msg += `one of type ${types.join(', ')}, or ${last}.`;
    }
    else if (types.length === 2) {
        msg += `one of type ${types[0]} or ${types[1]}.`;
    }
    else {
        msg += `of type ${types[0]}.`;
    }
    if (actual == null) {
        msg += ` Received ${actual}`;
    }
    else if (typeof actual === 'function' && actual.name) {
        msg += ` Received function ${actual.name}`;
    }
    else if (typeof actual === 'object' && actual != null) {
        if (actual.constructor && actual.constructor.name) {
            msg += ` Received an instance of ${actual.constructor.name}`;
        }
    }
    return msg;
}
var invalidKeyInput = (actual, ...types) => {
    return message('Key must be ', actual, ...types);
};
function withAlg(alg, actual, ...types) {
    return message(`Key for the ${alg} algorithm must be `, actual, ...types);
}

var isKeyLike = (key) => isKeyObject(key) || isCryptoKey(key);
const types = ['KeyObject'];
if (globalThis.CryptoKey || webcrypto?.CryptoKey) {
    types.push('CryptoKey');
}

const isDisjoint = (...headers) => {
    const sources = headers.filter(Boolean);
    if (sources.length === 0 || sources.length === 1) {
        return true;
    }
    let acc;
    for (const header of sources) {
        const parameters = Object.keys(header);
        if (!acc || acc.size === 0) {
            acc = new Set(parameters);
            continue;
        }
        for (const parameter of parameters) {
            if (acc.has(parameter)) {
                return false;
            }
            acc.add(parameter);
        }
    }
    return true;
};

function isObjectLike(value) {
    return typeof value === 'object' && value !== null;
}
function isObject(input) {
    if (!isObjectLike(input) || Object.prototype.toString.call(input) !== '[object Object]') {
        return false;
    }
    if (Object.getPrototypeOf(input) === null) {
        return true;
    }
    let proto = input;
    while (Object.getPrototypeOf(proto) !== null) {
        proto = Object.getPrototypeOf(proto);
    }
    return Object.getPrototypeOf(input) === proto;
}

const namedCurveToJOSE = (namedCurve) => {
    switch (namedCurve) {
        case 'prime256v1':
            return 'P-256';
        case 'secp384r1':
            return 'P-384';
        case 'secp521r1':
            return 'P-521';
        case 'secp256k1':
            return 'secp256k1';
        default:
            throw new JOSENotSupported('Unsupported key curve for this operation');
    }
};
const getNamedCurve = (kee, raw) => {
    let key;
    if (isCryptoKey(kee)) {
        key = KeyObject.from(kee);
    }
    else if (isKeyObject(kee)) {
        key = kee;
    }
    else {
        throw new TypeError(invalidKeyInput(kee, ...types));
    }
    if (key.type === 'secret') {
        throw new TypeError('only "private" or "public" type keys can be used for this operation');
    }
    switch (key.asymmetricKeyType) {
        case 'ed25519':
        case 'ed448':
            return `Ed${key.asymmetricKeyType.slice(2)}`;
        case 'x25519':
        case 'x448':
            return `X${key.asymmetricKeyType.slice(1)}`;
        case 'ec': {
            let namedCurve = key.asymmetricKeyDetails.namedCurve;
            if (raw) {
                return namedCurve;
            }
            return namedCurveToJOSE(namedCurve);
        }
        default:
            throw new TypeError('Invalid asymmetric key type for this operation');
    }
};

var checkKeyLength = (key, alg) => {
    const { modulusLength } = key.asymmetricKeyDetails;
    if (typeof modulusLength !== 'number' || modulusLength < 2048) {
        throw new TypeError(`${alg} requires key modulusLength to be 2048 bits or larger`);
    }
};

const fromSPKI = (pem) => createPublicKey({
    key: Buffer$1.from(pem.replace(/(?:-----(?:BEGIN|END) PUBLIC KEY-----|\s)/g, ''), 'base64'),
    type: 'spki',
    format: 'der',
});

async function importSPKI(spki, alg, options) {
    if (typeof spki !== 'string' || spki.indexOf('-----BEGIN PUBLIC KEY-----') !== 0) {
        throw new TypeError('"spki" must be SPKI formatted string');
    }
    return fromSPKI(spki, alg, options);
}

const symmetricTypeCheck = (alg, key) => {
    if (key instanceof Uint8Array)
        return;
    if (!isKeyLike(key)) {
        throw new TypeError(withAlg(alg, key, ...types, 'Uint8Array'));
    }
    if (key.type !== 'secret') {
        throw new TypeError(`${types.join(' or ')} instances for symmetric algorithms must be of type "secret"`);
    }
};
const asymmetricTypeCheck = (alg, key, usage) => {
    if (!isKeyLike(key)) {
        throw new TypeError(withAlg(alg, key, ...types));
    }
    if (key.type === 'secret') {
        throw new TypeError(`${types.join(' or ')} instances for asymmetric algorithms must not be of type "secret"`);
    }
    if (usage === 'sign' && key.type === 'public') {
        throw new TypeError(`${types.join(' or ')} instances for asymmetric algorithm signing must be of type "private"`);
    }
    if (usage === 'decrypt' && key.type === 'public') {
        throw new TypeError(`${types.join(' or ')} instances for asymmetric algorithm decryption must be of type "private"`);
    }
    if (key.algorithm && usage === 'verify' && key.type === 'private') {
        throw new TypeError(`${types.join(' or ')} instances for asymmetric algorithm verifying must be of type "public"`);
    }
    if (key.algorithm && usage === 'encrypt' && key.type === 'private') {
        throw new TypeError(`${types.join(' or ')} instances for asymmetric algorithm encryption must be of type "public"`);
    }
};
const checkKeyType = (alg, key, usage) => {
    const symmetric = alg.startsWith('HS') ||
        alg === 'dir' ||
        alg.startsWith('PBES2') ||
        /^A\d{3}(?:GCM)?KW$/.test(alg);
    if (symmetric) {
        symmetricTypeCheck(alg, key);
    }
    else {
        asymmetricTypeCheck(alg, key, usage);
    }
};

function validateCrit(Err, recognizedDefault, recognizedOption, protectedHeader, joseHeader) {
    if (joseHeader.crit !== undefined && protectedHeader.crit === undefined) {
        throw new Err('"crit" (Critical) Header Parameter MUST be integrity protected');
    }
    if (!protectedHeader || protectedHeader.crit === undefined) {
        return new Set();
    }
    if (!Array.isArray(protectedHeader.crit) ||
        protectedHeader.crit.length === 0 ||
        protectedHeader.crit.some((input) => typeof input !== 'string' || input.length === 0)) {
        throw new Err('"crit" (Critical) Header Parameter MUST be an array of non-empty strings when present');
    }
    let recognized;
    if (recognizedOption !== undefined) {
        recognized = new Map([...Object.entries(recognizedOption), ...recognizedDefault.entries()]);
    }
    else {
        recognized = recognizedDefault;
    }
    for (const parameter of protectedHeader.crit) {
        if (!recognized.has(parameter)) {
            throw new JOSENotSupported(`Extension Header Parameter "${parameter}" is not recognized`);
        }
        if (joseHeader[parameter] === undefined) {
            throw new Err(`Extension Header Parameter "${parameter}" is missing`);
        }
        else if (recognized.get(parameter) && protectedHeader[parameter] === undefined) {
            throw new Err(`Extension Header Parameter "${parameter}" MUST be integrity protected`);
        }
    }
    return new Set(protectedHeader.crit);
}

const validateAlgorithms = (option, algorithms) => {
    if (algorithms !== undefined &&
        (!Array.isArray(algorithms) || algorithms.some((s) => typeof s !== 'string'))) {
        throw new TypeError(`"${option}" option must be an array of strings`);
    }
    if (!algorithms) {
        return undefined;
    }
    return new Set(algorithms);
};

function dsaDigest(alg) {
    switch (alg) {
        case 'PS256':
        case 'RS256':
        case 'ES256':
        case 'ES256K':
            return 'sha256';
        case 'PS384':
        case 'RS384':
        case 'ES384':
            return 'sha384';
        case 'PS512':
        case 'RS512':
        case 'ES512':
            return 'sha512';
        case 'EdDSA':
            return undefined;
        default:
            throw new JOSENotSupported(`alg ${alg} is not supported either by JOSE or your javascript runtime`);
    }
}

const PSS = {
    padding: constants.RSA_PKCS1_PSS_PADDING,
    saltLength: constants.RSA_PSS_SALTLEN_DIGEST,
};
const ecCurveAlgMap = new Map([
    ['ES256', 'P-256'],
    ['ES256K', 'secp256k1'],
    ['ES384', 'P-384'],
    ['ES512', 'P-521'],
]);
function keyForCrypto(alg, key) {
    switch (alg) {
        case 'EdDSA':
            if (!['ed25519', 'ed448'].includes(key.asymmetricKeyType)) {
                throw new TypeError('Invalid key for this operation, its asymmetricKeyType must be ed25519 or ed448');
            }
            return key;
        case 'RS256':
        case 'RS384':
        case 'RS512':
            if (key.asymmetricKeyType !== 'rsa') {
                throw new TypeError('Invalid key for this operation, its asymmetricKeyType must be rsa');
            }
            checkKeyLength(key, alg);
            return key;
        case 'PS256':
        case 'PS384':
        case 'PS512':
            if (key.asymmetricKeyType === 'rsa-pss') {
                const { hashAlgorithm, mgf1HashAlgorithm, saltLength } = key.asymmetricKeyDetails;
                const length = parseInt(alg.slice(-3), 10);
                if (hashAlgorithm !== undefined &&
                    (hashAlgorithm !== `sha${length}` || mgf1HashAlgorithm !== hashAlgorithm)) {
                    throw new TypeError(`Invalid key for this operation, its RSA-PSS parameters do not meet the requirements of "alg" ${alg}`);
                }
                if (saltLength !== undefined && saltLength > length >> 3) {
                    throw new TypeError(`Invalid key for this operation, its RSA-PSS parameter saltLength does not meet the requirements of "alg" ${alg}`);
                }
            }
            else if (key.asymmetricKeyType !== 'rsa') {
                throw new TypeError('Invalid key for this operation, its asymmetricKeyType must be rsa or rsa-pss');
            }
            checkKeyLength(key, alg);
            return { key, ...PSS };
        case 'ES256':
        case 'ES256K':
        case 'ES384':
        case 'ES512': {
            if (key.asymmetricKeyType !== 'ec') {
                throw new TypeError('Invalid key for this operation, its asymmetricKeyType must be ec');
            }
            const actual = getNamedCurve(key);
            const expected = ecCurveAlgMap.get(alg);
            if (actual !== expected) {
                throw new TypeError(`Invalid key curve for the algorithm, its curve must be ${expected}, got ${actual}`);
            }
            return { dsaEncoding: 'ieee-p1363', key };
        }
        default:
            throw new JOSENotSupported(`alg ${alg} is not supported either by JOSE or your javascript runtime`);
    }
}

function hmacDigest(alg) {
    switch (alg) {
        case 'HS256':
            return 'sha256';
        case 'HS384':
            return 'sha384';
        case 'HS512':
            return 'sha512';
        default:
            throw new JOSENotSupported(`alg ${alg} is not supported either by JOSE or your javascript runtime`);
    }
}

function getSignVerifyKey(alg, key, usage) {
    if (key instanceof Uint8Array) {
        if (!alg.startsWith('HS')) {
            throw new TypeError(invalidKeyInput(key, ...types));
        }
        return createSecretKey(key);
    }
    if (key instanceof KeyObject) {
        return key;
    }
    if (isCryptoKey(key)) {
        checkSigCryptoKey(key, alg, usage);
        return KeyObject.from(key);
    }
    throw new TypeError(invalidKeyInput(key, ...types, 'Uint8Array'));
}

const oneShotSign = promisify(crypto.sign);
const sign = async (alg, key, data) => {
    const keyObject = getSignVerifyKey(alg, key, 'sign');
    if (alg.startsWith('HS')) {
        const hmac = crypto.createHmac(hmacDigest(alg), keyObject);
        hmac.update(data);
        return hmac.digest();
    }
    return oneShotSign(dsaDigest(alg), data, keyForCrypto(alg, keyObject));
};

const oneShotVerify = promisify(crypto.verify);
const verify = async (alg, key, signature, data) => {
    const keyObject = getSignVerifyKey(alg, key, 'verify');
    if (alg.startsWith('HS')) {
        const expected = await sign(alg, keyObject, data);
        const actual = signature;
        try {
            return crypto.timingSafeEqual(actual, expected);
        }
        catch {
            return false;
        }
    }
    const algorithm = dsaDigest(alg);
    const keyInput = keyForCrypto(alg, keyObject);
    try {
        return await oneShotVerify(algorithm, data, keyInput, signature);
    }
    catch {
        return false;
    }
};

async function flattenedVerify(jws, key, options) {
    if (!isObject(jws)) {
        throw new JWSInvalid('Flattened JWS must be an object');
    }
    if (jws.protected === undefined && jws.header === undefined) {
        throw new JWSInvalid('Flattened JWS must have either of the "protected" or "header" members');
    }
    if (jws.protected !== undefined && typeof jws.protected !== 'string') {
        throw new JWSInvalid('JWS Protected Header incorrect type');
    }
    if (jws.payload === undefined) {
        throw new JWSInvalid('JWS Payload missing');
    }
    if (typeof jws.signature !== 'string') {
        throw new JWSInvalid('JWS Signature missing or incorrect type');
    }
    if (jws.header !== undefined && !isObject(jws.header)) {
        throw new JWSInvalid('JWS Unprotected Header incorrect type');
    }
    let parsedProt = {};
    if (jws.protected) {
        try {
            const protectedHeader = decode(jws.protected);
            parsedProt = JSON.parse(decoder.decode(protectedHeader));
        }
        catch {
            throw new JWSInvalid('JWS Protected Header is invalid');
        }
    }
    if (!isDisjoint(parsedProt, jws.header)) {
        throw new JWSInvalid('JWS Protected and JWS Unprotected Header Parameter names must be disjoint');
    }
    const joseHeader = {
        ...parsedProt,
        ...jws.header,
    };
    const extensions = validateCrit(JWSInvalid, new Map([['b64', true]]), options?.crit, parsedProt, joseHeader);
    let b64 = true;
    if (extensions.has('b64')) {
        b64 = parsedProt.b64;
        if (typeof b64 !== 'boolean') {
            throw new JWSInvalid('The "b64" (base64url-encode payload) Header Parameter must be a boolean');
        }
    }
    const { alg } = joseHeader;
    if (typeof alg !== 'string' || !alg) {
        throw new JWSInvalid('JWS "alg" (Algorithm) Header Parameter missing or invalid');
    }
    const algorithms = options && validateAlgorithms('algorithms', options.algorithms);
    if (algorithms && !algorithms.has(alg)) {
        throw new JOSEAlgNotAllowed('"alg" (Algorithm) Header Parameter value not allowed');
    }
    if (b64) {
        if (typeof jws.payload !== 'string') {
            throw new JWSInvalid('JWS Payload must be a string');
        }
    }
    else if (typeof jws.payload !== 'string' && !(jws.payload instanceof Uint8Array)) {
        throw new JWSInvalid('JWS Payload must be a string or an Uint8Array instance');
    }
    let resolvedKey = false;
    if (typeof key === 'function') {
        key = await key(parsedProt, jws);
        resolvedKey = true;
    }
    checkKeyType(alg, key, 'verify');
    const data = concat(encoder.encode(jws.protected ?? ''), encoder.encode('.'), typeof jws.payload === 'string' ? encoder.encode(jws.payload) : jws.payload);
    let signature;
    try {
        signature = decode(jws.signature);
    }
    catch {
        throw new JWSInvalid('Failed to base64url decode the signature');
    }
    const verified = await verify(alg, key, signature, data);
    if (!verified) {
        throw new JWSSignatureVerificationFailed();
    }
    let payload;
    if (b64) {
        try {
            payload = decode(jws.payload);
        }
        catch {
            throw new JWSInvalid('Failed to base64url decode the payload');
        }
    }
    else if (typeof jws.payload === 'string') {
        payload = encoder.encode(jws.payload);
    }
    else {
        payload = jws.payload;
    }
    const result = { payload };
    if (jws.protected !== undefined) {
        result.protectedHeader = parsedProt;
    }
    if (jws.header !== undefined) {
        result.unprotectedHeader = jws.header;
    }
    if (resolvedKey) {
        return { ...result, key };
    }
    return result;
}

async function compactVerify(jws, key, options) {
    if (jws instanceof Uint8Array) {
        jws = decoder.decode(jws);
    }
    if (typeof jws !== 'string') {
        throw new JWSInvalid('Compact JWS must be a string or Uint8Array');
    }
    const { 0: protectedHeader, 1: payload, 2: signature, length } = jws.split('.');
    if (length !== 3) {
        throw new JWSInvalid('Invalid Compact JWS');
    }
    const verified = await flattenedVerify({ payload, protected: protectedHeader, signature }, key, options);
    const result = { payload: verified.payload, protectedHeader: verified.protectedHeader };
    if (typeof key === 'function') {
        return { ...result, key: verified.key };
    }
    return result;
}

var epoch = (date) => Math.floor(date.getTime() / 1000);

const minute = 60;
const hour = minute * 60;
const day = hour * 24;
const week = day * 7;
const year = day * 365.25;
const REGEX = /^(\+|\-)? ?(\d+|\d+\.\d+) ?(seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)(?: (ago|from now))?$/i;
var secs = (str) => {
    const matched = REGEX.exec(str);
    if (!matched || (matched[4] && matched[1])) {
        throw new TypeError('Invalid time period format');
    }
    const value = parseFloat(matched[2]);
    const unit = matched[3].toLowerCase();
    let numericDate;
    switch (unit) {
        case 'sec':
        case 'secs':
        case 'second':
        case 'seconds':
        case 's':
            numericDate = Math.round(value);
            break;
        case 'minute':
        case 'minutes':
        case 'min':
        case 'mins':
        case 'm':
            numericDate = Math.round(value * minute);
            break;
        case 'hour':
        case 'hours':
        case 'hr':
        case 'hrs':
        case 'h':
            numericDate = Math.round(value * hour);
            break;
        case 'day':
        case 'days':
        case 'd':
            numericDate = Math.round(value * day);
            break;
        case 'week':
        case 'weeks':
        case 'w':
            numericDate = Math.round(value * week);
            break;
        default:
            numericDate = Math.round(value * year);
            break;
    }
    if (matched[1] === '-' || matched[4] === 'ago') {
        return -numericDate;
    }
    return numericDate;
};

const normalizeTyp = (value) => value.toLowerCase().replace(/^application\//, '');
const checkAudiencePresence = (audPayload, audOption) => {
    if (typeof audPayload === 'string') {
        return audOption.includes(audPayload);
    }
    if (Array.isArray(audPayload)) {
        return audOption.some(Set.prototype.has.bind(new Set(audPayload)));
    }
    return false;
};
var jwtPayload = (protectedHeader, encodedPayload, options = {}) => {
    const { typ } = options;
    if (typ &&
        (typeof protectedHeader.typ !== 'string' ||
            normalizeTyp(protectedHeader.typ) !== normalizeTyp(typ))) {
        throw new JWTClaimValidationFailed('unexpected "typ" JWT header value', 'typ', 'check_failed');
    }
    let payload;
    try {
        payload = JSON.parse(decoder.decode(encodedPayload));
    }
    catch {
    }
    if (!isObject(payload)) {
        throw new JWTInvalid('JWT Claims Set must be a top-level JSON object');
    }
    const { requiredClaims = [], issuer, subject, audience, maxTokenAge } = options;
    const presenceCheck = [...requiredClaims];
    if (maxTokenAge !== undefined)
        presenceCheck.push('iat');
    if (audience !== undefined)
        presenceCheck.push('aud');
    if (subject !== undefined)
        presenceCheck.push('sub');
    if (issuer !== undefined)
        presenceCheck.push('iss');
    for (const claim of new Set(presenceCheck.reverse())) {
        if (!(claim in payload)) {
            throw new JWTClaimValidationFailed(`missing required "${claim}" claim`, claim, 'missing');
        }
    }
    if (issuer && !(Array.isArray(issuer) ? issuer : [issuer]).includes(payload.iss)) {
        throw new JWTClaimValidationFailed('unexpected "iss" claim value', 'iss', 'check_failed');
    }
    if (subject && payload.sub !== subject) {
        throw new JWTClaimValidationFailed('unexpected "sub" claim value', 'sub', 'check_failed');
    }
    if (audience &&
        !checkAudiencePresence(payload.aud, typeof audience === 'string' ? [audience] : audience)) {
        throw new JWTClaimValidationFailed('unexpected "aud" claim value', 'aud', 'check_failed');
    }
    let tolerance;
    switch (typeof options.clockTolerance) {
        case 'string':
            tolerance = secs(options.clockTolerance);
            break;
        case 'number':
            tolerance = options.clockTolerance;
            break;
        case 'undefined':
            tolerance = 0;
            break;
        default:
            throw new TypeError('Invalid clockTolerance option type');
    }
    const { currentDate } = options;
    const now = epoch(currentDate || new Date());
    if ((payload.iat !== undefined || maxTokenAge) && typeof payload.iat !== 'number') {
        throw new JWTClaimValidationFailed('"iat" claim must be a number', 'iat', 'invalid');
    }
    if (payload.nbf !== undefined) {
        if (typeof payload.nbf !== 'number') {
            throw new JWTClaimValidationFailed('"nbf" claim must be a number', 'nbf', 'invalid');
        }
        if (payload.nbf > now + tolerance) {
            throw new JWTClaimValidationFailed('"nbf" claim timestamp check failed', 'nbf', 'check_failed');
        }
    }
    if (payload.exp !== undefined) {
        if (typeof payload.exp !== 'number') {
            throw new JWTClaimValidationFailed('"exp" claim must be a number', 'exp', 'invalid');
        }
        if (payload.exp <= now - tolerance) {
            throw new JWTExpired('"exp" claim timestamp check failed', 'exp', 'check_failed');
        }
    }
    if (maxTokenAge) {
        const age = now - payload.iat;
        const max = typeof maxTokenAge === 'number' ? maxTokenAge : secs(maxTokenAge);
        if (age - tolerance > max) {
            throw new JWTExpired('"iat" claim timestamp check failed (too far in the past)', 'iat', 'check_failed');
        }
        if (age < 0 - tolerance) {
            throw new JWTClaimValidationFailed('"iat" claim timestamp check failed (it should be in the past)', 'iat', 'check_failed');
        }
    }
    return payload;
};

async function jwtVerify(jwt, key, options) {
    const verified = await compactVerify(jwt, key, options);
    if (verified.protectedHeader.crit?.includes('b64') && verified.protectedHeader.b64 === false) {
        throw new JWTInvalid('JWTs MUST NOT use unencoded payload');
    }
    const payload = jwtPayload(verified.protectedHeader, verified.payload, options);
    const result = { payload, protectedHeader: verified.protectedHeader };
    if (typeof key === 'function') {
        return { ...result, key: verified.key };
    }
    return result;
}

class CreateUserException extends Error {
    constructor(message) {
        super(message);
        this.fieldToErrors = JSON.parse(message);
    }
}
class MigrateUserException extends Error {
    constructor(message) {
        super(message);
        this.fieldToErrors = JSON.parse(message);
    }
}
class CreateOrgException extends Error {
    constructor(message) {
        super(message);
        this.fieldToErrors = JSON.parse(message);
    }
}
class AddUserToOrgException extends Error {
    constructor(message) {
        super(message);
        this.fieldToErrors = JSON.parse(message);
    }
}
class ChangeUserRoleInOrgException extends Error {
    constructor(message) {
        super(message);
        this.fieldToErrors = JSON.parse(message);
    }
}
class RemoveUserFromOrgException extends Error {
    constructor(message) {
        super(message);
        this.fieldToErrors = JSON.parse(message);
    }
}
class UpdateOrgException extends Error {
    constructor(message) {
        super(message);
        this.fieldToErrors = JSON.parse(message);
    }
}
class ForbiddenException extends Error {
    constructor(message) {
        super(message);
        this.message = message;
        this.status = 403;
    }
}
class MagicLinkCreationException extends Error {
    constructor(message) {
        super(message);
        this.fieldToErrors = JSON.parse(message);
    }
}
class AccessTokenCreationException extends Error {
    constructor(message) {
        super(message);
        this.fieldToErrors = JSON.parse(message);
    }
}
class UnauthorizedException extends Error {
    constructor(message) {
        super(message);
        this.message = message;
        this.status = 401;
    }
}
class UnexpectedException extends Error {
    constructor(message) {
        super(message);
        this.message = message;
        this.status = 503;
    }
}
class UpdateUserEmailException extends Error {
    constructor(message) {
        super(message);
        this.fieldToErrors = JSON.parse(message);
    }
}
class UpdateUserPasswordException extends Error {
    constructor(message) {
        super(message);
        this.fieldToErrors = JSON.parse(message);
    }
}
class UpdateUserMetadataException extends Error {
    constructor(message) {
        super(message);
        this.fieldToErrors = JSON.parse(message);
    }
}
class UserNotFoundException extends Error {
}
class ApiKeyValidateException extends Error {
    constructor(message) {
        super(message);
        this.fieldToErrors = JSON.parse(message);
    }
}
class ApiKeyDeleteException extends Error {
    constructor(message) {
        super(message);
        this.fieldToErrors = JSON.parse(message);
    }
}
class ApiKeyUpdateException extends Error {
    constructor(message) {
        super(message);
        this.fieldToErrors = JSON.parse(message);
    }
}
class ApiKeyCreateException extends Error {
    constructor(message) {
        super(message);
        this.fieldToErrors = JSON.parse(message);
    }
}
class ApiKeyFetchException extends Error {
    constructor(message) {
        super(message);
        this.fieldToErrors = JSON.parse(message);
    }
}
class BadRequestException extends Error {
    constructor(message) {
        super(message);
        this.fieldToErrors = JSON.parse(message);
    }
}

function httpRequest(authUrlOrigin, apiKey, path, method, body) {
    let headers = {
        Authorization: "Bearer " + apiKey,
        "Content-Type": "application/json",
    };
    if (body !== undefined) {
        headers["Content-Length"] = Buffer.byteLength(body);
    }
    return new Promise((resolve, reject) => {
        const req = http.request({
            protocol: authUrlOrigin.protocol,
            hostname: authUrlOrigin.hostname,
            port: authUrlOrigin.port,
            path: path,
            method: method,
            headers: headers,
        }, (res) => {
            let response = "";
            res.on("data", (data) => {
                response += data;
            });
            res.on("end", () => {
                resolve({
                    statusCode: res.statusCode,
                    response: response,
                });
            });
        });
        req.on("error", (error) => {
            reject(error);
        });
        if (body !== undefined) {
            req.write(body);
        }
        req.end();
    });
}

function toLoginMethod(snake_case) {
    if (!snake_case) {
        return { loginMethod: "unknown" };
    }
    switch (snake_case.login_method) {
        case "password":
            return { loginMethod: "password" };
        case "magic_link":
            return { loginMethod: "magic_link" };
        case "social_sso":
            return { loginMethod: "social_sso", provider: snake_case.provider };
        case "email_confirmation_link":
            return { loginMethod: "email_confirmation_link" };
        case "saml_sso":
            return { loginMethod: "saml_sso", provider: snake_case.provider, orgId: snake_case.org_id };
        case "impersonation":
            return { loginMethod: "impersonation" };
        case "generated_from_backend_api":
            return { loginMethod: "generated_from_backend_api" };
        default:
            return { loginMethod: "unknown" };
    }
}

class UserClass {
    constructor(user) {
        this.userId = user.userId;
        this.orgIdToUserOrgInfo = user.orgIdToOrgMemberInfo;
        this.email = user.email;
        this.firstName = user.firstName;
        this.lastName = user.lastName;
        this.username = user.username;
        this.legacyUserId = user.legacyUserId;
        this.impersonatorUserId = user.impersonatorUserId;
        this.properties = user.properties;
        this.loginMethod = user.loginMethod;
    }
    getOrg(orgId) {
        if (!this.orgIdToUserOrgInfo) {
            return undefined;
        }
        if (!this.orgIdToUserOrgInfo.hasOwnProperty(orgId)) {
            return undefined;
        }
        return this.orgIdToUserOrgInfo[orgId];
    }
    getOrgByName(orgName) {
        if (!this.orgIdToUserOrgInfo) {
            return undefined;
        }
        const urlSafeOrgName = orgName.toLowerCase().replace(/ /g, "-");
        for (const orgId in this.orgIdToUserOrgInfo) {
            const orgMemberInfo = this.getOrg(orgId);
            if ((orgMemberInfo === null || orgMemberInfo === void 0 ? void 0 : orgMemberInfo.urlSafeOrgName) === urlSafeOrgName) {
                return orgMemberInfo;
            }
        }
        return undefined;
    }
    getUserProperty(key) {
        if (!this.properties || !this.properties.hasOwnProperty(key)) {
            return undefined;
        }
        return this.properties[key];
    }
    getOrgs() {
        if (!this.orgIdToUserOrgInfo) {
            return [];
        }
        return Object.values(this.orgIdToUserOrgInfo);
    }
    isImpersonating() {
        return !!this.impersonatorUserId;
    }
    isRole(orgId, role) {
        const orgMemberInfo = this.getOrg(orgId);
        if (!orgMemberInfo) {
            return false;
        }
        return orgMemberInfo.isRole(role);
    }
    isAtLeastRole(orgId, role) {
        const orgMemberInfo = this.getOrg(orgId);
        if (!orgMemberInfo) {
            return false;
        }
        return orgMemberInfo.isAtLeastRole(role);
    }
    hasPermission(orgId, permission) {
        const orgMemberInfo = this.getOrg(orgId);
        if (!orgMemberInfo) {
            return false;
        }
        return orgMemberInfo.hasPermission(permission);
    }
    hasAllPermissions(orgId, permissions) {
        const orgMemberInfo = this.getOrg(orgId);
        if (!orgMemberInfo) {
            return false;
        }
        return orgMemberInfo.hasAllPermissions(permissions);
    }
    static fromUser(user) {
        return new UserClass(user);
    }
}
class OrgMemberInfo {
    constructor(orgId, orgName, orgMetadata, urlSafeOrgName, userAssignedRole, userInheritedRolesPlusCurrentRole, userPermissions) {
        this.orgId = orgId;
        this.orgName = orgName;
        this.orgMetadata = orgMetadata;
        this.urlSafeOrgName = urlSafeOrgName;
        this.userAssignedRole = userAssignedRole;
        this.userInheritedRolesPlusCurrentRole = userInheritedRolesPlusCurrentRole;
        this.userPermissions = userPermissions;
    }
    // getters
    get assignedRole() {
        return this.userAssignedRole;
    }
    get permissions() {
        return this.userPermissions;
    }
    get inheritedRolesPlusCurrentRole() {
        return this.userInheritedRolesPlusCurrentRole;
    }
    // validation methods
    isRole(role) {
        return this.userAssignedRole === role;
    }
    isAtLeastRole(role) {
        return this.userInheritedRolesPlusCurrentRole.includes(role);
    }
    hasPermission(permission) {
        return this.userPermissions.includes(permission);
    }
    hasAllPermissions(permissions) {
        return permissions.every((permission) => this.hasPermission(permission));
    }
    static fromJSON(json) {
        const obj = JSON.parse(json);
        try {
            return new OrgMemberInfo(obj.orgId, obj.orgName, obj.orgMetadata, obj.urlSafeOrgName, obj.userAssignedRole, obj.userInheritedRolesPlusCurrentRole, obj.userPermissions);
        }
        catch (e) {
            console.error("Unable to parse UserOrgInfo. Make sure the JSON string is a stringified `UserOrgInfo` type.", e);
            throw e;
        }
    }
}
function toUser(snake_case) {
    const camelCase = {
        userId: snake_case.user_id,
        orgIdToOrgMemberInfo: toOrgIdToOrgMemberInfo(snake_case.org_id_to_org_member_info),
        email: snake_case.email,
        firstName: snake_case.first_name,
        lastName: snake_case.last_name,
        username: snake_case.username,
        legacyUserId: snake_case.legacy_user_id,
        impersonatorUserId: snake_case.impersonator_user_id,
        metadata: snake_case.metadata,
        properties: snake_case.properties,
        loginMethod: toLoginMethod(snake_case.login_method),
    };
    return camelCase;
}
function toOrgIdToOrgMemberInfo(snake_case) {
    if (snake_case === undefined) {
        return undefined;
    }
    const camelCase = {};
    for (const key of Object.keys(snake_case)) {
        const snakeCaseValue = snake_case[key];
        if (snakeCaseValue) {
            camelCase[key] = new OrgMemberInfo(snakeCaseValue.org_id, snakeCaseValue.org_name, snakeCaseValue.org_metadata, snakeCaseValue.url_safe_org_name, snakeCaseValue.user_role, snakeCaseValue.inherited_user_roles_plus_current_role, snakeCaseValue.user_permissions);
        }
    }
    return camelCase;
}

const idRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
const hexRegex = /^[0-9a-fA-F]{32}$/i;
function isValidId(id) {
    return idRegex.test(id);
}
function isValidHex(id) {
    return hexRegex.test(id);
}
function removeBearerIfExists(token) {
    if (!token) {
        return token;
    }
    else if (token.toLowerCase().startsWith("bearer ")) {
        return token.substring(7);
    }
    else {
        return token;
    }
}
function formatQueryParameters(obj) {
    const params = new URLSearchParams();
    for (const [key, value] of Object.entries(obj)) {
        if (value !== undefined) {
            params.set(key, value);
        }
    }
    return params.toString();
}
function parseSnakeCaseToCamelCase(response) {
    let parsedObject = JSON.parse(response);
    return processKeys(parsedObject);
}
const keysForValueNotToModify = ["metadata", "org_metadata"];
function isOrgMemberInfo(value) {
    return (value &&
        typeof value === "object" &&
        value.hasOwnProperty("orgId") &&
        value.hasOwnProperty("orgName") &&
        value.hasOwnProperty("urlSafeOrgName") &&
        value.hasOwnProperty("orgMetadata") &&
        value.hasOwnProperty("userAssignedRole") &&
        value.hasOwnProperty("userRoles") &&
        value.hasOwnProperty("userPermissions"));
}
function processKeys(obj) {
    let newObj = Array.isArray(obj) ? [] : {};
    for (let key in obj) {
        if (!obj.hasOwnProperty(key)) {
            continue;
        }
        let value = obj[key];
        const doNotModifyValue = keysForValueNotToModify.includes(key);
        if (!doNotModifyValue && value && typeof value === "object") {
            value = processKeys(value);
        }
        if (isOrgMemberInfo(value)) {
            value = new OrgMemberInfo(value["orgId"], value["orgName"], value["orgMetadata"], value["urlSafeOrgName"], value["userAssignedRole"], value["userRoles"], value["userPermissions"]);
        }
        let newKey;
        if (key === "user_role") {
            newKey = "userAssignedRole";
        }
        else if (key === "inherited_user_roles_plus_current_role") {
            newKey = "userRoles";
        }
        else {
            newKey = camelCase(key);
        }
        newObj[newKey] = value;
    }
    return newObj;
}
function camelCase(key) {
    return key.replace(/_([a-z])/g, function (g) {
        return g[1].toUpperCase();
    });
}

const ENDPOINT_PATH$6 = "/api/backend/v1/access_token";
// POST
function createAccessToken(authUrl, integrationApiKey, createAccessTokenRequest) {
    if (!isValidId(createAccessTokenRequest.userId)) {
        throw new UserNotFoundException();
    }
    const request = {
        user_id: createAccessTokenRequest.userId,
        duration_in_minutes: createAccessTokenRequest.durationInMinutes,
    };
    return httpRequest(authUrl, integrationApiKey, ENDPOINT_PATH$6, "POST", JSON.stringify(request)).then((httpResponse) => {
        if (httpResponse.statusCode === 401) {
            throw new Error("integrationApiKey is incorrect");
        }
        else if (httpResponse.statusCode === 400) {
            throw new AccessTokenCreationException(httpResponse.response);
        }
        else if (httpResponse.statusCode === 403) {
            throw new UserNotFoundException();
        }
        else if (httpResponse.statusCode === 404) {
            throw new Error("Access token creation is not enabled");
        }
        else if (httpResponse.statusCode && httpResponse.statusCode >= 400) {
            throw new Error("Unknown error when creating access token");
        }
        return JSON.parse(httpResponse.response);
    });
}

const ENDPOINT_PATH$5 = "/api/backend/v1/end_user_api_keys";
// GET
function fetchApiKey(authUrl, integrationApiKey, apiKeyId) {
    if (!isValidHex(apiKeyId)) {
        throw new ApiKeyFetchException("Invalid api key");
    }
    return httpRequest(authUrl, integrationApiKey, `${ENDPOINT_PATH$5}/${apiKeyId}`, "GET").then((httpResponse) => {
        if (httpResponse.statusCode === 401) {
            throw new Error("integrationApiKey is incorrect");
        }
        else if (httpResponse.statusCode === 400) {
            throw new ApiKeyFetchException(httpResponse.response);
        }
        else if (httpResponse.statusCode && httpResponse.statusCode >= 400) {
            throw new Error("Unknown error when creating the end user api key");
        }
        return parseSnakeCaseToCamelCase(httpResponse.response);
    });
}
function fetchCurrentApiKeys(authUrl, integrationApiKey, apiKeyQuery) {
    const request = {
        org_id: apiKeyQuery.orgId,
        user_id: apiKeyQuery.userId,
        user_email: apiKeyQuery.userEmail,
        page_size: apiKeyQuery.pageSize,
        page_number: apiKeyQuery.pageNumber,
    };
    const queryString = formatQueryParameters(request);
    return httpRequest(authUrl, integrationApiKey, `${ENDPOINT_PATH$5}?${queryString}`, "GET").then((httpResponse) => {
        if (httpResponse.statusCode === 401) {
            throw new Error("integrationApiKey is incorrect");
        }
        else if (httpResponse.statusCode === 400) {
            throw new ApiKeyFetchException(httpResponse.response);
        }
        else if (httpResponse.statusCode && httpResponse.statusCode >= 400) {
            throw new Error("Unknown error when creating the end user api key");
        }
        return parseSnakeCaseToCamelCase(httpResponse.response);
    });
}
function fetchArchivedApiKeys(authUrl, integrationApiKey, apiKeyQuery) {
    const request = {
        org_id: apiKeyQuery.orgId,
        user_id: apiKeyQuery.userId,
        user_email: apiKeyQuery.userEmail,
        page_size: apiKeyQuery.pageSize,
        page_number: apiKeyQuery.pageNumber,
    };
    const queryString = formatQueryParameters(request);
    return httpRequest(authUrl, integrationApiKey, `${ENDPOINT_PATH$5}/archived?${queryString}`, "GET").then((httpResponse) => {
        if (httpResponse.statusCode === 401) {
            throw new Error("integrationApiKey is incorrect");
        }
        else if (httpResponse.statusCode === 400) {
            throw new ApiKeyFetchException(httpResponse.response);
        }
        else if (httpResponse.statusCode && httpResponse.statusCode >= 400) {
            throw new Error("Unknown error when creating the end user api key");
        }
        return parseSnakeCaseToCamelCase(httpResponse.response);
    });
}
function createApiKey(authUrl, integrationApiKey, apiKeyCreate) {
    const request = {
        org_id: apiKeyCreate.orgId,
        user_id: apiKeyCreate.userId,
        expires_at_seconds: apiKeyCreate.expiresAtSeconds,
        metadata: apiKeyCreate.metadata,
    };
    return httpRequest(authUrl, integrationApiKey, `${ENDPOINT_PATH$5}`, "POST", JSON.stringify(request)).then((httpResponse) => {
        if (httpResponse.statusCode === 401) {
            throw new Error("integrationApiKey is incorrect");
        }
        else if (httpResponse.statusCode === 400) {
            throw new ApiKeyCreateException(httpResponse.response);
        }
        else if (httpResponse.statusCode && httpResponse.statusCode >= 400) {
            throw new Error("Unknown error when creating the end user api key");
        }
        return parseSnakeCaseToCamelCase(httpResponse.response);
    });
}
function validateApiKey(authUrl, integrationApiKey, apiKeyToken) {
    const request = {
        api_key_token: removeBearerIfExists(apiKeyToken),
    };
    return httpRequest(authUrl, integrationApiKey, `${ENDPOINT_PATH$5}/validate`, "POST", JSON.stringify(request)).then((httpResponse) => {
        if (httpResponse.statusCode === 401) {
            throw new Error("integrationApiKey is incorrect");
        }
        else if (httpResponse.statusCode === 400) {
            throw new ApiKeyValidateException(httpResponse.response);
        }
        else if (httpResponse.statusCode && httpResponse.statusCode >= 400) {
            throw new Error("Unknown error when updating the end user api key");
        }
        return parseSnakeCaseToCamelCase(httpResponse.response);
    });
}
function updateApiKey(authUrl, integrationApiKey, apiKeyId, apiKeyUpdate) {
    if (!isValidHex(apiKeyId)) {
        throw new ApiKeyUpdateException("Invalid api key");
    }
    const request = {
        expires_at_seconds: apiKeyUpdate.expiresAtSeconds,
        metadata: apiKeyUpdate.metadata,
    };
    return httpRequest(authUrl, integrationApiKey, `${ENDPOINT_PATH$5}/${apiKeyId}`, "PATCH", JSON.stringify(request)).then((httpResponse) => {
        if (httpResponse.statusCode === 401) {
            throw new Error("integrationApiKey is incorrect");
        }
        else if (httpResponse.statusCode === 400) {
            throw new ApiKeyUpdateException(httpResponse.response);
        }
        else if (httpResponse.statusCode && httpResponse.statusCode >= 400) {
            throw new Error("Unknown error when updating the end user api key");
        }
        return true;
    });
}
// DELETE
function deleteApiKey(authUrl, integrationApiKey, apiKeyId) {
    if (!isValidHex(apiKeyId)) {
        throw new ApiKeyDeleteException("Invalid api key");
    }
    return httpRequest(authUrl, integrationApiKey, `${ENDPOINT_PATH$5}/${apiKeyId}`, "DELETE").then((httpResponse) => {
        if (httpResponse.statusCode === 401) {
            throw new Error("integrationApiKey is incorrect");
        }
        else if (httpResponse.statusCode === 400) {
            throw new ApiKeyDeleteException(httpResponse.response);
        }
        else if (httpResponse.statusCode === 404) {
            return false;
        }
        else if (httpResponse.statusCode && httpResponse.statusCode >= 400) {
            throw new Error("Unknown error when deleting the end user api key");
        }
        return true;
    });
}

const ENDPOINT_PATH$4 = "/api/backend/v1/magic_link";
// POST
function createMagicLink(authUrl, integrationApiKey, createMagicLinkRequest) {
    const request = {
        email: createMagicLinkRequest.email,
        redirect_to_url: createMagicLinkRequest.redirectToUrl,
        expires_in_hours: createMagicLinkRequest.expiresInHours,
        create_new_user_if_one_doesnt_exist: createMagicLinkRequest.createNewUserIfOneDoesntExist,
    };
    return httpRequest(authUrl, integrationApiKey, ENDPOINT_PATH$4, "POST", JSON.stringify(request)).then((httpResponse) => {
        if (httpResponse.statusCode === 401) {
            throw new Error("integrationApiKey is incorrect");
        }
        else if (httpResponse.statusCode === 400) {
            throw new MagicLinkCreationException(httpResponse.response);
        }
        else if (httpResponse.statusCode && httpResponse.statusCode >= 400) {
            throw new Error("Unknown error when creating magic link");
        }
        return JSON.parse(httpResponse.response);
    });
}

const ENDPOINT_PATH$3 = "/api/backend/v1/migrate_user";
function migrateUserFromExternalSource(authUrl, integrationApiKey, migrateUserFromExternalSourceRequest) {
    const request = {
        email: migrateUserFromExternalSourceRequest.email,
        email_confirmed: migrateUserFromExternalSourceRequest.emailConfirmed,
        existing_user_id: migrateUserFromExternalSourceRequest.existingUserId,
        existing_password_hash: migrateUserFromExternalSourceRequest.existingPasswordHash,
        existing_mfa_base32_encoded_secret: migrateUserFromExternalSourceRequest.existingMfaBase32EncodedSecret,
        update_password_required: migrateUserFromExternalSourceRequest.askUserToUpdatePasswordOnLogin,
        enabled: migrateUserFromExternalSourceRequest.enabled,
        first_name: migrateUserFromExternalSourceRequest.firstName,
        last_name: migrateUserFromExternalSourceRequest.lastName,
        username: migrateUserFromExternalSourceRequest.username,
        properties: migrateUserFromExternalSourceRequest.properties,
    };
    return httpRequest(authUrl, integrationApiKey, `${ENDPOINT_PATH$3}/`, "POST", JSON.stringify(request)).then((httpResponse) => {
        if (httpResponse.statusCode === 401) {
            throw new Error("integrationApiKey is incorrect");
        }
        else if (httpResponse.statusCode === 400) {
            throw new MigrateUserException(httpResponse.response);
        }
        else if (httpResponse.statusCode && httpResponse.statusCode >= 400) {
            throw new Error("Unknown error when migrating user");
        }
        return parseSnakeCaseToCamelCase(httpResponse.response);
    });
}

const ENDPOINT_PATH$2 = "/api/backend/v1/org";
// GET
function fetchOrg(authUrl, integrationApiKey, orgId) {
    if (!isValidId(orgId)) {
        return Promise.resolve(null);
    }
    return httpRequest(authUrl, integrationApiKey, `${ENDPOINT_PATH$2}/${orgId}`, "GET").then((httpResponse) => {
        if (httpResponse.statusCode === 401) {
            throw new Error("integrationApiKey is incorrect");
        }
        else if (httpResponse.statusCode === 404) {
            return null;
        }
        else if (httpResponse.statusCode === 426) {
            throw new Error("Cannot use organizations unless B2B support is enabled. Enable it in your PropelAuth dashboard.");
        }
        else if (httpResponse.statusCode && httpResponse.statusCode >= 400) {
            throw new Error("Unknown error when fetching org");
        }
        return parseSnakeCaseToCamelCase(httpResponse.response);
    });
}
function fetchOrgByQuery(authUrl, integrationApiKey, query) {
    const request = {
        page_size: query.pageSize,
        page_number: query.pageNumber,
        order_by: query.orderBy,
    };
    return httpRequest(authUrl, integrationApiKey, `${ENDPOINT_PATH$2}/query`, "POST", JSON.stringify(request)).then((httpResponse) => {
        if (httpResponse.statusCode === 401) {
            throw new Error("integrationApiKey is incorrect");
        }
        else if (httpResponse.statusCode === 400) {
            throw new Error("Invalid query " + httpResponse.response);
        }
        else if (httpResponse.statusCode === 426) {
            throw new Error("Cannot use organizations unless B2B support is enabled. Enable it in your PropelAuth dashboard.");
        }
        else if (httpResponse.statusCode && httpResponse.statusCode >= 400) {
            throw new Error("Unknown error when fetching orgs by query");
        }
        return JSON.parse(httpResponse.response, function (key, value) {
            if (key === "org_id") {
                this.orgId = value;
            }
            else if (key === "org_name") {
                this.name = value;
            }
            else if (key === "max_users") {
                this.maxUsers = value;
            }
            else if (key === "total_orgs") {
                this.totalOrgs = value;
            }
            else if (key === "current_page") {
                this.currentPage = value;
            }
            else if (key === "page_size") {
                this.pageSize = value;
            }
            else if (key === "has_more_results") {
                this.hasMoreResults = value;
            }
            else {
                return value;
            }
        });
    });
}
function createOrg(authUrl, integrationApiKey, createOrgRequest) {
    const { name, domain, enableAutoJoiningByDomain = false, membersMustHaveMatchingDomain = false, maxUsers, } = createOrgRequest;
    const request = {
        name,
        enable_auto_joining_by_domain: enableAutoJoiningByDomain,
        members_must_have_matching_domain: membersMustHaveMatchingDomain,
    };
    if (domain) {
        request["domain"] = domain;
    }
    if (maxUsers) {
        request["max_users"] = maxUsers;
    }
    return httpRequest(authUrl, integrationApiKey, `${ENDPOINT_PATH$2}/`, "POST", JSON.stringify(request)).then((httpResponse) => {
        if (httpResponse.statusCode === 401) {
            throw new Error("integrationApiKey is incorrect");
        }
        else if (httpResponse.statusCode === 400) {
            throw new CreateOrgException(httpResponse.response);
        }
        else if (httpResponse.statusCode && httpResponse.statusCode >= 400) {
            throw new Error("Unknown error when creating org");
        }
        return parseSnakeCaseToCamelCase(httpResponse.response);
    });
}
function addUserToOrg(authUrl, integrationApiKey, addUserToOrgRequest) {
    const request = {
        user_id: addUserToOrgRequest.userId,
        org_id: addUserToOrgRequest.orgId,
        role: addUserToOrgRequest.role,
    };
    return httpRequest(authUrl, integrationApiKey, `${ENDPOINT_PATH$2}/add_user`, "POST", JSON.stringify(request)).then((httpResponse) => {
        if (httpResponse.statusCode === 401) {
            throw new Error("integrationApiKey is incorrect");
        }
        else if (httpResponse.statusCode === 400) {
            throw new AddUserToOrgException(httpResponse.response);
        }
        else if (httpResponse.statusCode === 404) {
            return false;
        }
        else if (httpResponse.statusCode && httpResponse.statusCode >= 400) {
            throw new Error("Unknown error when adding user to org");
        }
        return true;
    });
}
function changeUserRoleInOrg(authUrl, integrationApiKey, changeUserRoleInOrgRequest) {
    const request = {
        user_id: changeUserRoleInOrgRequest.userId,
        org_id: changeUserRoleInOrgRequest.orgId,
        role: changeUserRoleInOrgRequest.role,
    };
    return httpRequest(authUrl, integrationApiKey, `${ENDPOINT_PATH$2}/change_role`, "POST", JSON.stringify(request)).then((httpResponse) => {
        if (httpResponse.statusCode === 401) {
            throw new Error("integrationApiKey is incorrect");
        }
        else if (httpResponse.statusCode === 400) {
            throw new ChangeUserRoleInOrgException(httpResponse.response);
        }
        else if (httpResponse.statusCode === 404) {
            return false;
        }
        else if (httpResponse.statusCode && httpResponse.statusCode >= 400) {
            throw new Error("Unknown error when changing users role in org");
        }
        return true;
    });
}
function removeUserFromOrg(authUrl, integrationApiKey, removeUserFromOrgRequest) {
    const request = {
        user_id: removeUserFromOrgRequest.userId,
        org_id: removeUserFromOrgRequest.orgId,
    };
    return httpRequest(authUrl, integrationApiKey, `${ENDPOINT_PATH$2}/remove_user`, "POST", JSON.stringify(request)).then((httpResponse) => {
        if (httpResponse.statusCode === 401) {
            throw new Error("integrationApiKey is incorrect");
        }
        else if (httpResponse.statusCode === 400) {
            throw new RemoveUserFromOrgException(httpResponse.response);
        }
        else if (httpResponse.statusCode === 404) {
            return false;
        }
        else if (httpResponse.statusCode && httpResponse.statusCode >= 400) {
            throw new Error("Unknown error when removing users from org");
        }
        return true;
    });
}
function allowOrgToSetupSamlConnection(authUrl, integrationApiKey, orgId) {
    if (!isValidId(orgId)) {
        return Promise.resolve(false);
    }
    return httpRequest(authUrl, integrationApiKey, `${ENDPOINT_PATH$2}/${orgId}/allow_saml`, "POST").then((httpResponse) => {
        if (httpResponse.statusCode === 401) {
            throw new Error("integrationApiKey is incorrect");
        }
        else if (httpResponse.statusCode === 404) {
            return false;
        }
        else if (httpResponse.statusCode && httpResponse.statusCode >= 400) {
            throw new Error("Unknown error when allowing org to setup SAML connection");
        }
        return true;
    });
}
function disallowOrgToSetupSamlConnection(authUrl, integrationApiKey, orgId) {
    if (!isValidId(orgId)) {
        return Promise.resolve(false);
    }
    return httpRequest(authUrl, integrationApiKey, `${ENDPOINT_PATH$2}/${orgId}/disallow_saml`, "POST").then((httpResponse) => {
        if (httpResponse.statusCode === 401) {
            throw new Error("integrationApiKey is incorrect");
        }
        else if (httpResponse.statusCode === 404) {
            return false;
        }
        else if (httpResponse.statusCode && httpResponse.statusCode >= 400) {
            throw new Error("Unknown error when disallowing org to setup SAML connection");
        }
        return true;
    });
}
function updateOrg(authUrl, integrationApiKey, updateOrgRequest) {
    if (!isValidId(updateOrgRequest.orgId)) {
        return Promise.resolve(false);
    }
    const request = {
        name: updateOrgRequest.name,
        can_setup_saml: updateOrgRequest.canSetupSaml,
        metadata: updateOrgRequest.metadata,
        max_users: updateOrgRequest.maxUsers,
        autojoin_by_domain: updateOrgRequest.canJoinOnEmailDomainMatch,
        restrict_to_domain: updateOrgRequest.membersMustHaveEmailDomainMatch,
        domain: updateOrgRequest.domain,
    };
    return httpRequest(authUrl, integrationApiKey, `${ENDPOINT_PATH$2}/${updateOrgRequest.orgId}`, "PUT", JSON.stringify(request)).then((httpResponse) => {
        if (httpResponse.statusCode === 401) {
            throw new Error("integrationApiKey is incorrect");
        }
        else if (httpResponse.statusCode === 400) {
            throw new UpdateOrgException(httpResponse.response);
        }
        else if (httpResponse.statusCode === 404) {
            return false;
        }
        else if (httpResponse.statusCode && httpResponse.statusCode >= 400) {
            throw new Error("Unknown error when updating org");
        }
        return true;
    });
}
// DELETE
function deleteOrg(authUrl, integrationApiKey, orgId) {
    if (!isValidId(orgId)) {
        return Promise.resolve(false);
    }
    return httpRequest(authUrl, integrationApiKey, `${ENDPOINT_PATH$2}/${orgId}`, "DELETE").then((httpResponse) => {
        if (httpResponse.statusCode === 401) {
            throw new Error("integrationApiKey is incorrect");
        }
        else if (httpResponse.statusCode === 404) {
            return false;
        }
        else if (httpResponse.statusCode && httpResponse.statusCode >= 400) {
            throw new Error("Unknown error when deleting org");
        }
        return true;
    });
}

const ENDPOINT_PATH$1 = "/api/v1/token_verification_metadata";
// GET
function fetchTokenVerificationMetadata(authUrl, integrationApiKey, manualTokenVerificationMetadata) {
    if (manualTokenVerificationMetadata) {
        return Promise.resolve(manualTokenVerificationMetadata);
    }
    return httpRequest(authUrl, integrationApiKey, ENDPOINT_PATH$1, "GET").then((httpResponse) => {
        if (httpResponse.statusCode === 401) {
            console.error("Your API key is incorrect");
            throw new Error("integrationApiKey is incorrect");
        }
        else if (httpResponse.statusCode && httpResponse.statusCode >= 400) {
            console.error(`Error fetching token verification metadata: ${httpResponse.statusCode}`);
            throw new Error("Unknown error when fetching token verification metadata");
        }
        const jsonParse = JSON.parse(httpResponse.response);
        return {
            verifierKey: jsonParse.verifier_key_pem,
            issuer: formatIssuer(authUrl),
        };
    });
}
const getTokenVerificationMetadataPromise = (tokenVerificationMetadataPromise) => __awaiter(void 0, void 0, void 0, function* () {
    const tokenVerificationMetadata = yield tokenVerificationMetadataPromise;
    if (!tokenVerificationMetadata) {
        const errorMessage = `Auth library not initialized, rejecting request. 
            This can mean that your API key was invalid or that the request to fetch token metadata failed. 
            Sometimes, this can happen if you are deploying to an environment without external internet access. 
            One workaround is to skip the fetch by passing in manualTokenVerificationMetadata to the initialization function.`;
        console.error(errorMessage);
        throw new UnexpectedException(errorMessage);
    }
    try {
        const publicKey = yield importSPKI(tokenVerificationMetadata.verifierKey, "RS256");
        return {
            publicKey,
            tokenVerificationMetadata,
        };
    }
    catch (e) {
        const publicKeyErrorMessage = "Error initializing auth library. Unable to import public key";
        console.error(publicKeyErrorMessage);
        throw new UnexpectedException(publicKeyErrorMessage);
    }
});
function formatIssuer(authUrl) {
    return authUrl.origin;
}

const ENDPOINT_PATH = "/api/backend/v1/user";
// GET
function fetchUserMetadataByQuery(authUrl, integrationApiKey, pathParam, query) {
    const queryString = formatQueryParameters(query);
    return httpRequest(authUrl, integrationApiKey, `${ENDPOINT_PATH}/${pathParam}?${queryString}`, "GET").then((httpResponse) => {
        if (httpResponse.statusCode === 401) {
            throw new Error("integrationApiKey is incorrect");
        }
        else if (httpResponse.statusCode === 404) {
            return null;
        }
        else if (httpResponse.statusCode && httpResponse.statusCode >= 400) {
            throw new Error("Unknown error when fetching user metadata");
        }
        return parseSnakeCaseToCamelCase(httpResponse.response);
    });
}
function fetchUserMetadataByUserIdWithIdCheck(authUrl, integrationApiKey, userId, includeOrgs) {
    if (isValidId(userId)) {
        return fetchUserMetadataByQuery(authUrl, integrationApiKey, userId, { include_orgs: includeOrgs || false });
    }
    else {
        return Promise.resolve(null);
    }
}
function fetchUsersByQuery(authUrl, integrationApiKey, query) {
    const queryParams = {
        page_size: query.pageSize,
        page_number: query.pageNumber,
        order_by: query.orderBy,
        email_or_username: query.emailOrUsername,
        include_orgs: query.includeOrgs,
    };
    const q = formatQueryParameters(queryParams);
    return httpRequest(authUrl, integrationApiKey, `${ENDPOINT_PATH}/query?${q}`, "GET").then((httpResponse) => {
        if (httpResponse.statusCode === 401) {
            throw new Error("integrationApiKey is incorrect");
        }
        else if (httpResponse.statusCode === 400) {
            throw new Error("Invalid query " + httpResponse.response);
        }
        else if (httpResponse.statusCode && httpResponse.statusCode >= 400) {
            throw new Error("Unknown error when fetching users by query");
        }
        return parseSnakeCaseToCamelCase(httpResponse.response);
    });
}
function fetchUsersInOrg(authUrl, integrationApiKey, query) {
    if (!isValidId(query.orgId)) {
        const emptyResponse = {
            users: [],
            totalUsers: 0,
            currentPage: query.pageNumber || 0,
            pageSize: query.pageSize || 10,
            hasMoreResults: false,
        };
        return Promise.resolve(emptyResponse);
    }
    const queryParams = {
        page_size: query.pageSize,
        page_number: query.pageNumber,
        include_orgs: query.includeOrgs,
    };
    const queryString = formatQueryParameters(queryParams);
    return httpRequest(authUrl, integrationApiKey, `${ENDPOINT_PATH}/org/${query.orgId}?${queryString}`, "GET").then((httpResponse) => {
        if (httpResponse.statusCode === 401) {
            throw new Error("integrationApiKey is incorrect");
        }
        else if (httpResponse.statusCode === 400) {
            throw new Error("Invalid query " + httpResponse.response);
        }
        else if (httpResponse.statusCode && httpResponse.statusCode >= 400) {
            throw new Error("Unknown error when fetching users in org");
        }
        return parseSnakeCaseToCamelCase(httpResponse.response);
    });
}
// POST
function fetchBatchUserMetadata(authUrl, integrationApiKey, type, values, keyFunction, includeOrgs) {
    const queryString = includeOrgs ? formatQueryParameters({ include_orgs: includeOrgs }) : "";
    const jsonBody = { [type]: values };
    return httpRequest(authUrl, integrationApiKey, `${ENDPOINT_PATH}/${type}?${queryString}`, "POST", JSON.stringify(jsonBody)).then((httpResponse) => {
        if (httpResponse.statusCode === 401) {
            throw new Error("integrationApiKey is incorrect");
        }
        else if (httpResponse.statusCode === 400) {
            throw new Error("Bad request " + httpResponse.response);
        }
        else if (httpResponse.statusCode && httpResponse.statusCode >= 400) {
            throw new Error("Unknown error when fetching batch user metadata");
        }
        const userMetadatas = parseSnakeCaseToCamelCase(httpResponse.response);
        const returnValue = {};
        for (let userMetadata of userMetadatas) {
            returnValue[keyFunction(userMetadata)] = userMetadata;
        }
        return returnValue;
    });
}
function createUser(authUrl, integrationApiKey, createUserRequest) {
    const request = {
        email: createUserRequest.email,
        email_confirmed: createUserRequest.emailConfirmed,
        send_email_to_confirm_email_address: createUserRequest.sendEmailToConfirmEmailAddress,
        password: createUserRequest.password,
        ask_user_to_update_password_on_login: createUserRequest.askUserToUpdatePasswordOnLogin,
        username: createUserRequest.username,
        first_name: createUserRequest.firstName,
        last_name: createUserRequest.lastName,
        properties: createUserRequest.properties,
    };
    return httpRequest(authUrl, integrationApiKey, `${ENDPOINT_PATH}/`, "POST", JSON.stringify(request)).then((httpResponse) => {
        if (httpResponse.statusCode === 401) {
            throw new Error("integrationApiKey is incorrect");
        }
        else if (httpResponse.statusCode === 400) {
            throw new CreateUserException(httpResponse.response);
        }
        else if (httpResponse.statusCode && httpResponse.statusCode >= 400) {
            throw new Error("Unknown error when creating user");
        }
        return parseSnakeCaseToCamelCase(httpResponse.response);
    });
}
function disableUser(authUrl, integrationApiKey, userId) {
    if (!isValidId(userId)) {
        return Promise.resolve(false);
    }
    return httpRequest(authUrl, integrationApiKey, `${ENDPOINT_PATH}/${userId}/disable`, "POST").then((httpResponse) => {
        if (httpResponse.statusCode === 401) {
            throw new Error("integrationApiKey is incorrect");
        }
        else if (httpResponse.statusCode === 404) {
            return false;
        }
        else if (httpResponse.statusCode && httpResponse.statusCode >= 400) {
            throw new Error("Unknown error when disabling user");
        }
        return true;
    });
}
function enableUser(authUrl, integrationApiKey, userId) {
    if (!isValidId(userId)) {
        return Promise.resolve(false);
    }
    return httpRequest(authUrl, integrationApiKey, `${ENDPOINT_PATH}/${userId}/enable`, "POST").then((httpResponse) => {
        if (httpResponse.statusCode === 401) {
            throw new Error("integrationApiKey is incorrect");
        }
        else if (httpResponse.statusCode === 404) {
            return false;
        }
        else if (httpResponse.statusCode && httpResponse.statusCode >= 400) {
            throw new Error("Unknown error when enabling user");
        }
        return true;
    });
}
function disableUser2fa(authUrl, integrationApiKey, userId) {
    if (!isValidId(userId)) {
        return Promise.resolve(false);
    }
    return httpRequest(authUrl, integrationApiKey, `${ENDPOINT_PATH}/${userId}/disable_2fa`, "POST").then((httpResponse) => {
        if (httpResponse.statusCode === 401) {
            throw new Error("integrationApiKey is incorrect");
        }
        else if (httpResponse.statusCode === 404) {
            return false;
        }
        else if (httpResponse.statusCode && httpResponse.statusCode >= 400) {
            throw new Error("Unknown error when disabling 2FA");
        }
        return true;
    });
}
function inviteUserToOrg(authUrl, integrationApiKey, inviteUserToOrgRequest) {
    const body = {
        org_id: inviteUserToOrgRequest.orgId,
        email: inviteUserToOrgRequest.email,
        role: inviteUserToOrgRequest.role,
    };
    return httpRequest(authUrl, integrationApiKey, `/api/backend/v1/invite_user`, "POST", JSON.stringify(body)).then((httpResponse) => {
        if (httpResponse.statusCode === 401) {
            throw new Error("integrationApiKey is incorrect");
        }
        else if (httpResponse.statusCode === 400) {
            throw new BadRequestException(httpResponse.response);
        }
        else if (httpResponse.statusCode === 404) {
            return false;
        }
        else if (httpResponse.statusCode && httpResponse.statusCode >= 400) {
            throw new Error("Unknown error when inviting a user to the org");
        }
        return true;
    });
}
function updateUserMetadata(authUrl, integrationApiKey, userId, updateUserMetadataRequest) {
    if (!isValidId(userId)) {
        return Promise.resolve(false);
    }
    const request = {
        username: updateUserMetadataRequest.username,
        first_name: updateUserMetadataRequest.firstName,
        last_name: updateUserMetadataRequest.lastName,
        picture_url: updateUserMetadataRequest.pictureUrl,
        metadata: updateUserMetadataRequest.metadata,
        properties: updateUserMetadataRequest.properties,
        update_password_required: updateUserMetadataRequest.updatePasswordRequired,
    };
    return httpRequest(authUrl, integrationApiKey, `${ENDPOINT_PATH}/${userId}`, "PUT", JSON.stringify(request)).then((httpResponse) => {
        if (httpResponse.statusCode === 401) {
            throw new Error("integrationApiKey is incorrect");
        }
        else if (httpResponse.statusCode === 400) {
            throw new UpdateUserMetadataException(httpResponse.response);
        }
        else if (httpResponse.statusCode === 404) {
            return false;
        }
        else if (httpResponse.statusCode && httpResponse.statusCode >= 400) {
            throw new Error("Unknown error when updating user metadata");
        }
        return true;
    });
}
function updateUserEmail(authUrl, integrationApiKey, userId, updateUserEmail) {
    if (!isValidId(userId)) {
        return Promise.resolve(false);
    }
    const request = {
        new_email: updateUserEmail.newEmail,
        require_email_confirmation: updateUserEmail.requireEmailConfirmation,
    };
    return httpRequest(authUrl, integrationApiKey, `${ENDPOINT_PATH}/${userId}/email`, "PUT", JSON.stringify(request)).then((httpResponse) => {
        if (httpResponse.statusCode === 401) {
            throw new Error("integrationApiKey is incorrect");
        }
        else if (httpResponse.statusCode === 400) {
            throw new UpdateUserEmailException(httpResponse.response);
        }
        else if (httpResponse.statusCode === 404) {
            return false;
        }
        else if (httpResponse.statusCode && httpResponse.statusCode >= 400) {
            throw new Error("Unknown error when creating user");
        }
        return true;
    });
}
function updateUserPassword(authUrl, integrationApiKey, userId, updateUserPasswordRequest) {
    if (!isValidId(userId)) {
        return Promise.resolve(false);
    }
    const request = {
        password: updateUserPasswordRequest.password,
        ask_user_to_update_password_on_login: updateUserPasswordRequest.askUserToUpdatePasswordOnLogin,
    };
    return httpRequest(authUrl, integrationApiKey, `${ENDPOINT_PATH}/${userId}/password`, "PUT", JSON.stringify(request)).then((httpResponse) => {
        if (httpResponse.statusCode === 401) {
            throw new Error("integrationApiKey is incorrect");
        }
        else if (httpResponse.statusCode === 400) {
            throw new UpdateUserPasswordException(httpResponse.response);
        }
        else if (httpResponse.statusCode === 404) {
            return false;
        }
        else if (httpResponse.statusCode && httpResponse.statusCode >= 400) {
            throw new Error("Unknown error when updating password");
        }
        return true;
    });
}
function enableUserCanCreateOrgs(authUrl, integrationApiKey, userId) {
    if (!isValidId(userId)) {
        return Promise.resolve(false);
    }
    return httpRequest(authUrl, integrationApiKey, `${ENDPOINT_PATH}/${userId}/can_create_orgs/enable`, "PUT").then((httpResponse) => {
        if (httpResponse.statusCode === 401) {
            throw new Error("integrationApiKey is incorrect");
        }
        else if (httpResponse.statusCode === 404) {
            return false;
        }
        else if (httpResponse.statusCode && httpResponse.statusCode >= 400) {
            throw new Error("Unknown error when enabling canCreateOrgs");
        }
        return true;
    });
}
function disableUserCanCreateOrgs(authUrl, integrationApiKey, userId) {
    if (!isValidId(userId)) {
        return Promise.resolve(false);
    }
    return httpRequest(authUrl, integrationApiKey, `${ENDPOINT_PATH}/${userId}/can_create_orgs/disable`, "PUT").then((httpResponse) => {
        if (httpResponse.statusCode === 401) {
            throw new Error("integrationApiKey is incorrect");
        }
        else if (httpResponse.statusCode === 404) {
            return false;
        }
        else if (httpResponse.statusCode && httpResponse.statusCode >= 400) {
            throw new Error("Unknown error when disabling canCreateOrgs");
        }
        return true;
    });
}
function clearUserPassword(authUrl, integrationApiKey, userId) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!isValidId(userId)) {
            return Promise.resolve(false);
        }
        const httpResponse = yield httpRequest(authUrl, integrationApiKey, `${ENDPOINT_PATH}/${userId}/clear_password`, "PUT");
        if (httpResponse.statusCode === 401) {
            throw new Error("integrationApiKey is incorrect");
        }
        else if (httpResponse.statusCode && httpResponse.statusCode >= 400) {
            throw new Error("Unknown error when clearing password");
        }
        return true;
    });
}
// DELETE
function deleteUser(authUrl, integrationApiKey, userId) {
    if (!isValidId(userId)) {
        return Promise.resolve(false);
    }
    return httpRequest(authUrl, integrationApiKey, `${ENDPOINT_PATH}/${userId}`, "DELETE").then((httpResponse) => {
        if (httpResponse.statusCode === 401) {
            throw new Error("integrationApiKey is incorrect");
        }
        else if (httpResponse.statusCode === 404) {
            return false;
        }
        else if (httpResponse.statusCode && httpResponse.statusCode >= 400) {
            throw new Error("Unknown error when deleting user");
        }
        return true;
    });
}
function fetchUserSignupQueryParams(authUrl, integrationApiKey, userId) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!isValidId(userId)) {
            return Promise.resolve(null);
        }
        const httpResponse = yield httpRequest(authUrl, integrationApiKey, `${ENDPOINT_PATH}/${userId}/signup_query_parameters`, "GET");
        if (httpResponse.statusCode === 401) {
            throw new Error("integrationApiKey is incorrect");
        }
        else if (httpResponse.statusCode === 404) {
            return null;
        }
        else if (httpResponse.statusCode && httpResponse.statusCode >= 400) {
            throw new Error("Unknown error when fetching user signup query params");
        }
        const snakeCase = JSON.parse(httpResponse.response);
        return { userSignupQueryParameters: snakeCase["user_signup_query_parameters"] };
    });
}

function validateAuthUrl(authUrl) {
    try {
        return new URL(authUrl);
    }
    catch (e) {
        console.error("Invalid authUrl", e);
        throw new Error("Unable to initialize auth client");
    }
}
function validatePersonalApiKey(authUrl, integrationApiKey, apiKeyToken) {
    return __awaiter(this, void 0, void 0, function* () {
        const apiKeyValidation = yield validateApiKey(authUrl, integrationApiKey, apiKeyToken);
        if (!apiKeyValidation.user || apiKeyValidation.org) {
            throw new ApiKeyValidateException(JSON.stringify({ api_key_token: ["Not a personal API Key"] }));
        }
        return {
            user: apiKeyValidation.user,
            metadata: apiKeyValidation.metadata,
        };
    });
}
function validateOrgApiKey(authUrl, integrationApiKey, apiKeyToken) {
    return __awaiter(this, void 0, void 0, function* () {
        const apiKeyValidation = yield validateApiKey(authUrl, integrationApiKey, apiKeyToken);
        if (!apiKeyValidation.org) {
            throw new ApiKeyValidateException(JSON.stringify({ api_key_token: ["Not an org API Key"] }));
        }
        return {
            org: apiKeyValidation.org,
            metadata: apiKeyValidation.metadata,
            user: apiKeyValidation.user,
            userInOrg: apiKeyValidation.userInOrg,
        };
    });
}

function initBaseAuth(opts) {
    const authUrl = validateAuthUrl(opts.authUrl);
    const integrationApiKey = opts.apiKey;
    // A promise that resolves to the token verification metadata, whether it's fetched or manually provided
    const tokenVerificationMetadataPromise = fetchTokenVerificationMetadata(authUrl, integrationApiKey, opts.manualTokenVerificationMetadata).catch((err) => {
        console.error("Error initializing auth library. ", err);
    });
    // A promise that resolves to the token verification metadata with the public key imported
    const tokenVerificationMetadataWithPublicKeyPromise = getTokenVerificationMetadataPromise(tokenVerificationMetadataPromise);
    const validateAccessTokenAndGetUser = wrapValidateAccessTokenAndGetUser(tokenVerificationMetadataWithPublicKeyPromise);
    const validateAccessTokenAndGetUserWithOrgInfo = wrapValidateAccessTokenAndGetUserWithOrgInfo(tokenVerificationMetadataWithPublicKeyPromise);
    const validateAccessTokenAndGetUserWithOrgInfoWithMinimumRole = wrapValidateAccessTokenAndGetUserWithOrgInfoWithMinimumRole(tokenVerificationMetadataWithPublicKeyPromise);
    const validateAccessTokenAndGetUserWithOrgInfoWithExactRole = wrapValidateAccessTokenAndGetUserWithOrgInfoWithExactRole(tokenVerificationMetadataWithPublicKeyPromise);
    const validateAccessTokenAndGetUserWithOrgInfoWithPermission = wrapValidateAccessTokenAndGetUserWithOrgInfoWithPermission(tokenVerificationMetadataWithPublicKeyPromise);
    const validateAccessTokenAndGetUserWithOrgInfoWithAllPermissions = wrapValidateAccessTokenAndGetUserWithOrgInfoWithAllPermissions(tokenVerificationMetadataWithPublicKeyPromise);
    function fetchUserMetadataByUserId(userId, includeOrgs) {
        return fetchUserMetadataByUserIdWithIdCheck(authUrl, integrationApiKey, userId, includeOrgs);
    }
    function fetchUserMetadataByEmail(email, includeOrgs) {
        return fetchUserMetadataByQuery(authUrl, integrationApiKey, "email", {
            email: email,
            include_orgs: includeOrgs || false,
        });
    }
    function fetchUserMetadataByUsername(username, includeOrgs) {
        return fetchUserMetadataByQuery(authUrl, integrationApiKey, "username", {
            username: username,
            include_orgs: includeOrgs || false,
        });
    }
    function fetchUserSignupQueryParamsWrapper(userId) {
        return fetchUserSignupQueryParams(authUrl, integrationApiKey, userId);
    }
    function fetchBatchUserMetadataByUserIds(userIds, includeOrgs) {
        return fetchBatchUserMetadata(authUrl, integrationApiKey, "user_ids", userIds, (x) => x.userId, includeOrgs || false);
    }
    function fetchBatchUserMetadataByEmails(emails, includeOrgs) {
        return fetchBatchUserMetadata(authUrl, integrationApiKey, "emails", emails, (x) => x.email, includeOrgs || false);
    }
    function fetchBatchUserMetadataByUsernames(usernames, includeOrgs) {
        return fetchBatchUserMetadata(authUrl, integrationApiKey, "usernames", usernames, (x) => x.username || "", includeOrgs || false);
    }
    function fetchOrgWrapper(orgId) {
        return fetchOrg(authUrl, integrationApiKey, orgId);
    }
    function fetchOrgsByQueryWrapper(orgQuery) {
        return fetchOrgByQuery(authUrl, integrationApiKey, orgQuery);
    }
    function fetchUsersByQueryWrapper(usersQuery) {
        return fetchUsersByQuery(authUrl, integrationApiKey, usersQuery);
    }
    function fetchUsersInOrgWrapper(usersInOrgQuery) {
        return fetchUsersInOrg(authUrl, integrationApiKey, usersInOrgQuery);
    }
    function createUserWrapper(createUserRequest) {
        return createUser(authUrl, integrationApiKey, createUserRequest);
    }
    function clearUserPasswordWrapper(userId) {
        return clearUserPassword(authUrl, integrationApiKey, userId);
    }
    function updateUserMetadataWrapper(userId, updateUserMetadataRequest) {
        return updateUserMetadata(authUrl, integrationApiKey, userId, updateUserMetadataRequest);
    }
    function deleteUserWrapper(userId) {
        return deleteUser(authUrl, integrationApiKey, userId);
    }
    function disableUserWrapper(userId) {
        return disableUser(authUrl, integrationApiKey, userId);
    }
    function enableUserWrapper(userId) {
        return enableUser(authUrl, integrationApiKey, userId);
    }
    function disableUser2faWrapper(userId) {
        return disableUser2fa(authUrl, integrationApiKey, userId);
    }
    function updateUserEmailWrapper(userId, updateUserEmailRequest) {
        return updateUserEmail(authUrl, integrationApiKey, userId, updateUserEmailRequest);
    }
    function updateUserPasswordWrapper(userId, updateUserPasswordRequest) {
        return updateUserPassword(authUrl, integrationApiKey, userId, updateUserPasswordRequest);
    }
    function enableUserCanCreateOrgsWrapper(userId) {
        return enableUserCanCreateOrgs(authUrl, integrationApiKey, userId);
    }
    function disableUserCanCreateOrgsWrapper(userId) {
        return disableUserCanCreateOrgs(authUrl, integrationApiKey, userId);
    }
    function createMagicLinkWrapper(createMagicLinkRequest) {
        return createMagicLink(authUrl, integrationApiKey, createMagicLinkRequest);
    }
    function createAccessTokenWrapper(createAccessTokenRequest) {
        return createAccessToken(authUrl, integrationApiKey, createAccessTokenRequest);
    }
    function migrateUserFromExternalSourceWrapper(migrateUserFromExternalSourceRequest) {
        return migrateUserFromExternalSource(authUrl, integrationApiKey, migrateUserFromExternalSourceRequest);
    }
    function createOrgWrapper(createOrgRequest) {
        return createOrg(authUrl, integrationApiKey, createOrgRequest);
    }
    function addUserToOrgWrapper(addUserToOrgRequest) {
        return addUserToOrg(authUrl, integrationApiKey, addUserToOrgRequest);
    }
    function changeUserRoleInOrgWrapper(changeUserRoleInOrgRequest) {
        return changeUserRoleInOrg(authUrl, integrationApiKey, changeUserRoleInOrgRequest);
    }
    function removeUserFromOrgWrapper(removeUserFromOrgRequest) {
        return removeUserFromOrg(authUrl, integrationApiKey, removeUserFromOrgRequest);
    }
    function updateOrgWrapper(updateOrgRequest) {
        return updateOrg(authUrl, integrationApiKey, updateOrgRequest);
    }
    function deleteOrgWrapper(orgId) {
        return deleteOrg(authUrl, integrationApiKey, orgId);
    }
    function allowOrgToSetupSamlConnectionWrapper(orgId) {
        return allowOrgToSetupSamlConnection(authUrl, integrationApiKey, orgId);
    }
    function disallowOrgToSetupSamlConnectionWrapper(orgId) {
        return disallowOrgToSetupSamlConnection(authUrl, integrationApiKey, orgId);
    }
    function inviteUserToOrgWrapper(inviteUserToOrgRequest) {
        return inviteUserToOrg(authUrl, integrationApiKey, inviteUserToOrgRequest);
    }
    // end user api key wrappers
    function fetchApiKeyWrapper(apiKeyId) {
        return fetchApiKey(authUrl, integrationApiKey, apiKeyId);
    }
    function fetchCurrentApiKeysWrapper(apiKeyQuery) {
        return fetchCurrentApiKeys(authUrl, integrationApiKey, apiKeyQuery);
    }
    function fetchArchivedApiKeysWrapper(apiKeyQuery) {
        return fetchArchivedApiKeys(authUrl, integrationApiKey, apiKeyQuery);
    }
    function createApiKeyWrapper(apiKeyCreate) {
        return createApiKey(authUrl, integrationApiKey, apiKeyCreate);
    }
    function updateApiKeyWrapper(apiKeyId, ApiKeyUpdate) {
        return updateApiKey(authUrl, integrationApiKey, apiKeyId, ApiKeyUpdate);
    }
    function deleteApiKeyWrapper(apiKeyId) {
        return deleteApiKey(authUrl, integrationApiKey, apiKeyId);
    }
    function validatePersonalApiKeyWrapper(apiKeyToken) {
        return validatePersonalApiKey(authUrl, integrationApiKey, apiKeyToken);
    }
    function validateOrgApiKeyWrapper(apiKeyToken) {
        return validateOrgApiKey(authUrl, integrationApiKey, apiKeyToken);
    }
    function validateApiKeyWrapper(apiKeyToken) {
        return validateApiKey(authUrl, integrationApiKey, apiKeyToken);
    }
    return {
        // validate and fetching functions
        validateAccessTokenAndGetUser,
        validateAccessTokenAndGetUserWithOrgInfo,
        validateAccessTokenAndGetUserWithOrgInfoWithMinimumRole,
        validateAccessTokenAndGetUserWithOrgInfoWithExactRole,
        validateAccessTokenAndGetUserWithOrgInfoWithPermission,
        validateAccessTokenAndGetUserWithOrgInfoWithAllPermissions,
        // fetching functions
        fetchUserMetadataByUserId,
        fetchUserMetadataByEmail,
        fetchUserMetadataByUsername,
        fetchUserSignupQueryParams: fetchUserSignupQueryParamsWrapper,
        fetchBatchUserMetadataByUserIds,
        fetchBatchUserMetadataByEmails,
        fetchBatchUserMetadataByUsernames,
        fetchOrg: fetchOrgWrapper,
        fetchOrgByQuery: fetchOrgsByQueryWrapper,
        fetchUsersByQuery: fetchUsersByQueryWrapper,
        fetchUsersInOrg: fetchUsersInOrgWrapper,
        // user management functions
        createUser: createUserWrapper,
        clearUserPassword: clearUserPasswordWrapper,
        updateUserMetadata: updateUserMetadataWrapper,
        updateUserEmail: updateUserEmailWrapper,
        updateUserPassword: updateUserPasswordWrapper,
        createMagicLink: createMagicLinkWrapper,
        createAccessToken: createAccessTokenWrapper,
        migrateUserFromExternalSource: migrateUserFromExternalSourceWrapper,
        deleteUser: deleteUserWrapper,
        disableUser: disableUserWrapper,
        enableUser: enableUserWrapper,
        disableUser2fa: disableUser2faWrapper,
        enableUserCanCreateOrgs: enableUserCanCreateOrgsWrapper,
        disableUserCanCreateOrgs: disableUserCanCreateOrgsWrapper,
        // org management functions
        createOrg: createOrgWrapper,
        addUserToOrg: addUserToOrgWrapper,
        changeUserRoleInOrg: changeUserRoleInOrgWrapper,
        removeUserFromOrg: removeUserFromOrgWrapper,
        updateOrg: updateOrgWrapper,
        deleteOrg: deleteOrgWrapper,
        allowOrgToSetupSamlConnection: allowOrgToSetupSamlConnectionWrapper,
        disallowOrgToSetupSamlConnection: disallowOrgToSetupSamlConnectionWrapper,
        inviteUserToOrg: inviteUserToOrgWrapper,
        // api keys functions
        fetchApiKey: fetchApiKeyWrapper,
        fetchCurrentApiKeys: fetchCurrentApiKeysWrapper,
        fetchArchivedApiKeys: fetchArchivedApiKeysWrapper,
        createApiKey: createApiKeyWrapper,
        updateApiKey: updateApiKeyWrapper,
        deleteApiKey: deleteApiKeyWrapper,
        validateApiKey: validateApiKeyWrapper,
        validatePersonalApiKey: validatePersonalApiKeyWrapper,
        validateOrgApiKey: validateOrgApiKeyWrapper,
    };
}
// wrapper function with no validation
function wrapValidateAccessTokenAndGetUser(tokenVerificationMetadataWithPublicKeyPromise) {
    return function validateAccessTokenAndGetUser(authorizationHeader) {
        return __awaiter(this, void 0, void 0, function* () {
            return extractAndVerifyBearerToken(tokenVerificationMetadataWithPublicKeyPromise, authorizationHeader);
        });
    };
}
// The following four functions are wrappers around our four validations: isRole, atLeastRole, hasPermission, hasAllPermissions
// Each function returns an OrgMemberInfo object
function wrapValidateAccessTokenAndGetUserWithOrgInfo(tokenVerificationMetadataWithPublicKeyPromise) {
    return function validateAccessTokenAndGetUserWithOrgInfo(authorizationHeader, requiredOrgInfo) {
        return __awaiter(this, void 0, void 0, function* () {
            const user = yield extractAndVerifyBearerToken(tokenVerificationMetadataWithPublicKeyPromise, authorizationHeader);
            const orgMemberInfo = validateOrgAccessAndGetOrgMemberInfo(user, requiredOrgInfo);
            return { user, orgMemberInfo };
        });
    };
}
function wrapValidateAccessTokenAndGetUserWithOrgInfoWithMinimumRole(tokenVerificationMetadataWithPublicKeyPromise) {
    return function validateAccessTokenAndGetUserWithOrgInfo(authorizationHeader, requiredOrgInfo, minimumRole) {
        return __awaiter(this, void 0, void 0, function* () {
            const user = yield extractAndVerifyBearerToken(tokenVerificationMetadataWithPublicKeyPromise, authorizationHeader);
            const orgMemberInfo = validateOrgAccessAndGetOrgMemberInfoWithMinimumRole(user, requiredOrgInfo, minimumRole);
            return { user, orgMemberInfo };
        });
    };
}
function wrapValidateAccessTokenAndGetUserWithOrgInfoWithExactRole(tokenVerificationMetadataWithPublicKeyPromise) {
    return function validateAccessTokenAndGetUserWithOrgInfo(authorizationHeader, requiredOrgInfo, exactRole) {
        return __awaiter(this, void 0, void 0, function* () {
            const user = yield extractAndVerifyBearerToken(tokenVerificationMetadataWithPublicKeyPromise, authorizationHeader);
            const orgMemberInfo = validateOrgAccessAndGetOrgMemberInfoWithExactRole(user, requiredOrgInfo, exactRole);
            return { user, orgMemberInfo };
        });
    };
}
function wrapValidateAccessTokenAndGetUserWithOrgInfoWithPermission(tokenVerificationMetadataWithPublicKeyPromise) {
    return function validateAccessTokenAndGetUserWithOrgInfo(authorizationHeader, requiredOrgInfo, permission) {
        return __awaiter(this, void 0, void 0, function* () {
            const user = yield extractAndVerifyBearerToken(tokenVerificationMetadataWithPublicKeyPromise, authorizationHeader);
            const orgMemberInfo = validateOrgAccessAndGetOrgMemberInfoWithPermission(user, requiredOrgInfo, permission);
            return { user, orgMemberInfo };
        });
    };
}
function wrapValidateAccessTokenAndGetUserWithOrgInfoWithAllPermissions(tokenVerificationMetadataWithPublicKeyPromise) {
    return function validateAccessTokenAndGetUserWithOrgInfo(authorizationHeader, requiredOrgInfo, permissions) {
        return __awaiter(this, void 0, void 0, function* () {
            const user = yield extractAndVerifyBearerToken(tokenVerificationMetadataWithPublicKeyPromise, authorizationHeader);
            const orgMemberInfo = validateOrgAccessAndGetOrgMemberInfoWithAllPermissions(user, requiredOrgInfo, permissions);
            return { user, orgMemberInfo };
        });
    };
}
// Validator functions
function validateOrgAccessAndGetOrgMemberInfo(user, requiredOrgInfo) {
    const orgMemberInfo = getUserInfoInOrg(requiredOrgInfo, user.orgIdToOrgMemberInfo);
    if (!orgMemberInfo) {
        throw new ForbiddenException(`User is not a member of org ${JSON.stringify(requiredOrgInfo)}`);
    }
    return orgMemberInfo;
}
function validateOrgAccessAndGetOrgMemberInfoWithMinimumRole(user, requiredOrgInfo, minimumRole) {
    const orgMemberInfo = getUserInfoInOrg(requiredOrgInfo, user.orgIdToOrgMemberInfo);
    if (!orgMemberInfo) {
        throw new ForbiddenException(`User is not a member of org ${JSON.stringify(requiredOrgInfo)}`);
    }
    if (!orgMemberInfo.isAtLeastRole(minimumRole)) {
        throw new ForbiddenException(`User's roles don't contain the minimum role (${minimumRole})`);
    }
    return orgMemberInfo;
}
function validateOrgAccessAndGetOrgMemberInfoWithExactRole(user, requiredOrgInfo, exactRole) {
    const orgMemberInfo = getUserInfoInOrg(requiredOrgInfo, user.orgIdToOrgMemberInfo);
    if (!orgMemberInfo) {
        throw new ForbiddenException(`User is not a member of org ${JSON.stringify(requiredOrgInfo)}`);
    }
    if (!orgMemberInfo.isRole(exactRole)) {
        throw new ForbiddenException(`User's assigned role isn't the required role (${exactRole})`);
    }
    return orgMemberInfo;
}
function validateOrgAccessAndGetOrgMemberInfoWithPermission(user, requiredOrgInfo, permission) {
    const orgMemberInfo = getUserInfoInOrg(requiredOrgInfo, user.orgIdToOrgMemberInfo);
    if (!orgMemberInfo) {
        throw new ForbiddenException(`User is not a member of org ${JSON.stringify(requiredOrgInfo)}`);
    }
    if (!orgMemberInfo.hasPermission(permission)) {
        throw new ForbiddenException(`User's permissions don't contain the required permission (${permission})`);
    }
    return orgMemberInfo;
}
function validateOrgAccessAndGetOrgMemberInfoWithAllPermissions(user, requiredOrgInfo, permissions) {
    const orgMemberInfo = getUserInfoInOrg(requiredOrgInfo, user.orgIdToOrgMemberInfo);
    if (!orgMemberInfo) {
        throw new ForbiddenException(`User is not a member of org ${JSON.stringify(requiredOrgInfo)}`);
    }
    if (!orgMemberInfo.hasAllPermissions(permissions)) {
        throw new ForbiddenException(`User's permissions don't contain all the required permissions (${permissions})`);
    }
    return orgMemberInfo;
}
// Miscellaneous functions
function getUserInfoInOrg(requiredOrgInfo, orgIdToOrgMemberInfo) {
    if (!orgIdToOrgMemberInfo) {
        return undefined;
    }
    else if (requiredOrgInfo.orgId) {
        // If we are looking for an orgId, we can do a direct lookup
        if (!orgIdToOrgMemberInfo.hasOwnProperty(requiredOrgInfo.orgId)) {
            return undefined;
        }
        const orgMemberInfo = orgIdToOrgMemberInfo[requiredOrgInfo.orgId];
        // We also need to verify the orgName matches, if specified
        if (requiredOrgInfo.orgName && orgNameMatches(requiredOrgInfo.orgName, orgMemberInfo)) {
            return orgMemberInfo;
        }
        else if (requiredOrgInfo.orgName) {
            return undefined;
        }
        else {
            return orgMemberInfo;
        }
    }
    else if (requiredOrgInfo.orgName) {
        // We know there's no required orgId so just iterate over orgMemberInfos looking for a matching urlSafeOrgName
        for (const orgMemberInfo of Object.values(orgIdToOrgMemberInfo)) {
            if (orgNameMatches(requiredOrgInfo.orgName, orgMemberInfo)) {
                return orgMemberInfo;
            }
        }
        return undefined;
    }
    else {
        return undefined;
    }
}
function orgNameMatches(orgName, orgMemberInfo) {
    return orgName === orgMemberInfo.orgName || orgName === orgMemberInfo.urlSafeOrgName;
}
function extractAndVerifyBearerToken(tokenVerificationMetadataWithPublicKeyPromise, authorizationHeader) {
    return __awaiter(this, void 0, void 0, function* () {
        const tokenVerificationMetadataWithPublicKey = yield tokenVerificationMetadataWithPublicKeyPromise;
        const { publicKey, tokenVerificationMetadata } = tokenVerificationMetadataWithPublicKey;
        const bearerToken = extractBearerToken(authorizationHeader);
        return verifyToken(bearerToken, tokenVerificationMetadata, publicKey);
    });
}
function extractBearerToken(authHeader) {
    if (!authHeader) {
        throw new UnauthorizedException("No authorization header found.");
    }
    const authHeaderParts = authHeader.split(" ");
    if (authHeaderParts.length !== 2 || authHeaderParts[0].toLowerCase() !== "bearer") {
        throw new UnauthorizedException("Invalid authorization header. Expected: Bearer {accessToken}");
    }
    return authHeaderParts[1];
}
function verifyToken(bearerToken, tokenVerificationMetadata, publicKey) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            const { payload } = yield jwtVerify(bearerToken, publicKey, {
                algorithms: ["RS256"],
                issuer: tokenVerificationMetadata.issuer,
            });
            return toUser(payload);
        }
        catch (e) {
            if (e instanceof Error) {
                throw new UnauthorizedException(e.message);
            }
            else {
                throw new UnauthorizedException("Unable to decode jwt");
            }
        }
    });
}
function handleError(e, opts) {
    if (opts && opts.logError) {
        console.error(e);
    }
    const detailedError = opts && opts.returnDetailedErrorToUser;
    if (e instanceof UnauthorizedException) {
        return {
            status: 401,
            message: detailedError ? e.message : "Unauthorized",
        };
    }
    else if (e instanceof ForbiddenException) {
        return {
            status: 403,
            message: detailedError ? e.message : "Forbidden",
        };
    }
    else {
        return {
            status: 401,
            message: "Unauthorized",
        };
    }
}

export { AccessTokenCreationException, AddUserToOrgException, ApiKeyCreateException, ApiKeyDeleteException, ApiKeyFetchException, ApiKeyUpdateException, ApiKeyValidateException, BadRequestException, CreateOrgException, CreateUserException, ForbiddenException, MagicLinkCreationException, MigrateUserException, OrgMemberInfo, UnauthorizedException, UnexpectedException, UpdateUserEmailException, UpdateUserMetadataException, UserClass, UserNotFoundException, handleError, initBaseAuth, toOrgIdToOrgMemberInfo, toUser };
//# sourceMappingURL=index.es.js.map
